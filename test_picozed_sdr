#!/usr/bin/env python3
#
# This script is used to coordinate saving the AD9361 output clock frequency
# and user-inputted MAC address to the u-boot environment as well as writing
# various data to flash memory after successful picozed SDR test runs.
#
# Note that it uses python3 and requires pexpect, pyserial, and picocom to
# be installed.
#
# It also currently assumes the use of a Prologix GPIB-USB controller as well
# as an Agilent 53131A frequency counter used to measure the output clock
# frequency from the AD9361.

import errno
import os
import sys

import pexpect
import serial

# UART and GPIB usb serial device paths
UART_DEV = '/dev/serial/by-id/usb-Silicon_Labs_CP2103_USB_to_UART_Bridge_Controller_0001-if00-port0'
GPIB_DEV = '/dev/serial/by-id/usb-Prologix_Prologix_GPIB-USB_Controller_PX93W44G-if00-port0'

# manufacturer MAC address prefix (Avnet's by default)
MAC_ADDR_OUI= '0002B5'


class GPIBError(Exception):
    """Generic exception for errors when querying the frequency counter."""


def gpib_get_freq():
    """Get current AD9361 output clock frequency.

    Note that this currently assumes the use of a Prologix GPIB-USB controller
    as well as an Agilent 53131A frequency counter.

    Returns: frequency in HZ
    """
    try:
        s = serial.Serial(GPIB_DEV)
    except OSError as e:
        if e.errno == errno.ENOENT:
            raise GPIBError("serial device doesn't exist: %s" % GPIB_DEV)
        raise GPIBError('issue opening serial device: %s: %s' % (GPIB_DEV, e))

    s.bytesize = serial.EIGHTBITS
    s.parity = serial.PARITY_NONE
    s.stopbits = serial.STOPBITS_ONE
    s.timeout = 2
    s.xonxoff = False
    s.rtscts = False
    s.dsrdtr = False
    s.writeTimeout = 0

    # encode unicode strings to be written into byte strings
    def _write(string):
        s.write(string.encode())

    if not s.isOpen():
        try:
            s.open()
        except Exception as e:
            raise GPIBError(e)

    s.flushInput()
    s.flushOutput()

    # initialize GPIB adapter
    _write('++mode 1\n')
    _write('++auto 1\n')
    _write('++addr 16\n')
    _write('++ver\n')
    gpib_device = s.readline().strip()
    if not gpib_device:
        raise GPIBError('error communicating with GPIB device')

    # confirm communication with frequency counter
    _write('*CLS;*RST;*IDN?\r\n')
    instrument_id = s.readline().strip()
    if not instrument_id:
        raise GPIBError('error communicating with frequency counter')

    # request the current measured frequency
    _write('*RST;*CLS;*SRE 0;*ESE 0;\r\n')
    _write(':STAT:PRES\r\n')
    _write(':DISP:CALC:MATH:STAT OFF\r\n')
    _write(':TRAC SCALE, 1.000000\r\n')
    # we're using channel 1
    _write(":FUNC 'FREQ 1'\r\n")
    _write(':FORM:DATA ASCII\r\n')
    # send expected value and scale so returned value is properly scaled
    _write(':MEASURE:FREQ? 4e7 HZ, 1 HZ\r\n')
    freq = s.readline().strip()
    # re-enable continuous mode for the frequency counter
    _write(':INIT:CONT ON\r\n')
    s.close()
    if not freq:
        raise GPIBError('error querying counter for current frequency')

    return int(float(freq))


def get_mac_addr():
    """Get MAC address for device.

    Requires that user input the device specific portion.

    Returns: MAC address string in xx:xx:xx:xx:xx:xx format.
    """
    suffix = None
    while suffix is None:
        orig_suffix = input('Enter the MAC address suffix (e.g. 0afa34): ')
        # remove all character spacers
        strip_spacers = orig_suffix.maketrans({x: None for x in ':-.'})
        suffix = orig_suffix.translate(strip_spacers)

        # check if it's a valid hex string
        invalid_hex = False
        try:
            int(suffix, 16)
        except ValueError:
            invalid_hex = True

        if len(suffix) != 6 or invalid_hex:
            print('Invalid MAC address suffix: %s' % orig_suffix)
            suffix = None

    mac_addr = MAC_ADDR_OUI + suffix
    mac_addr = '%s%s:%s%s:%s%s:%s%s:%s%s:%s%s' % tuple(mac_addr.lower())
    return mac_addr


def expect():
    """Pexpect loop to run after the tests complete successfully."""

    if not os.path.exists(UART_DEV):
        raise SystemExit('UART serial device node to picozed sdr missing')
    if not os.path.exists(GPIB_DEV):
        raise SystemExit('GPIB serial device node to frequency counter missing')

    try:
        p = pexpect.spawnu('picocom -b 115200 %s' % (UART_DEV,))
    except pexpect.exceptions.ExceptionPexpect:
        raise SystemExit('picocom is missing, please install it')

    # send output to the terminal and don't reprint input commands
    p.logfile = sys.stdout
    p.setecho(False)

    # output string specifying that the u-boot command line is ready
    prompt = 'zynq-uboot> '

    while 1:
        try:
            i = p.expect(['ALL TESTS PASSED', 'TESTS FAILED'], timeout=3600)
            if i == 1:
                # tests failed, restarting loop
                continue
            p.expect(prompt)

            # drive gpio 61 high to enable ad9361 clock out on pin 3 of the P3 fanout
            p.sendline('gpio set 61 1')
            p.expect(prompt)

            # run GPIB query to determine actual ad9361 reference clock
            # frequency and save it to the u-boot environment
            try:
                freq = gpib_get_freq()
            except GPIBError:
                print('\nError querying frequency counter, restarting loop...')
                continue
            p.sendline('setenv ad9361_ext_refclk %s' % hex(freq))
            p.expect(prompt)

            # current flash layout and info
            # 0x000000000000-0x000000500000 : "boot"
            # 0x000000500000-0x000000520000 : "bootenv"
            # 0x000000520000-0x000000540000 : "config"
            # 0x000000540000-0x000000fc0000 : "image"
            # 0x000000fc0000-0x000002000000 : "spare"
            #
            # dev:    size   erasesize  name
            # mtd0: 00500000 00001000 "boot"
            # mtd1: 00020000 00001000 "bootenv"
            # mtd2: 00020000 00001000 "config"
            # mtd3: 00a80000 00001000 "image"
            # mtd4: 01040000 00001000 "spare"

            # write data to flash
            p.sendline('sf probe')
            p.expect('SF: Detected N25Q256A')
            p.expect(prompt)
            p.sendline('fatload mmc 0 0x1000000 flash/BOOT.BIN')
            p.expect('.* bytes read')
            p.expect(prompt)
            p.sendline('sf update 0x1000000 0x0 0x00500000')
            p.expect('.* bytes written', timeout=180)
            p.expect(prompt)
            p.sendline('fatload mmc 0 0x1000000 uImage')
            p.expect('.* bytes read')
            p.expect(prompt)
            p.sendline('sf update 0x1000000 0x00540000 0x00a80000')
            p.expect('.* bytes written', timeout=300)
            p.expect(prompt)
            p.sendline('fatload mmc 0 0x1000000 Card-Filesystem-Repair/uramdisk.image.gz')
            p.expect('.* bytes read')
            p.expect(prompt)
            p.sendline('sf update 0x1000000 0x00fc0000 0x01040000')
            p.expect('.* bytes written', timeout=600)
            p.expect(prompt)
            #p.sendline('fatload mmc 0 0x1000000 flash/system.bit')
            #p.expect('.* bytes read')
            #p.expect(prompt)
            #p.sendline('sf update 0x1000000 0x00fc0000 0x01040000')
            #p.expect('.* bytes written', timeout=600)
            #p.expect(prompt)

            # set MAC address
            print()
            mac_addr = get_mac_addr()
            p.sendline('setenv ethaddr %s' % mac_addr)
            p.expect(prompt)
            p.sendline('saveenv')
            p.expect(prompt)
            print('\nBoard ready for shipping')
            print('Power off and insert next module for testing')
        except pexpect.TIMEOUT:
            print('\nTimed out waiting for u-boot output, restarting loop...')
            continue
    p.close()

if __name__ == '__main__':
    expect()
