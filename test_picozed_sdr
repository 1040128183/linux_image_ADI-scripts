#!/usr/bin/env python3
#
# This script is used to coordinate saving the AD9361 output clock frequency
# and user-inputted MAC address to the u-boot environment as well as writing
# various data to flash memory after successful picozed SDR test runs.
#
# Note that it uses python3 and requires pexpect, pyserial, and picocom to
# be installed.
#
# It also currently assumes the use of a Prologix GPIB-USB controller as well
# as an Agilent 53131A frequency counter used to measure the output clock
# frequency from the AD9361.

import errno
import os
import sys

import pexpect
import serial

# UART and GPIB usb serial device paths
UART_DEV = '/dev/serial/by-id/usb-Silicon_Labs_CP2103_USB_to_UART_Bridge_Controller_0001-if00-port0'
GPIB_DEV = '/dev/serial/by-id/usb-Prologix_Prologix_GPIB-USB_Controller_PX93W44G-if00-port0'

# manufacturer MAC address prefix (Avnet's by default)
MAC_ADDR_OUI= '0002B5'


class GPIBError(Exception):
    """Generic exception for errors when querying the frequency counter."""


class UBootError(Exception):
    """Generic exception for errors when communicating with u-boot."""


def gpib_get_freq():
    """Get current AD9361 output clock frequency.

    Note that this currently assumes the use of a Prologix GPIB-USB controller
    as well as an Agilent 53131A frequency counter.

    Returns: frequency in HZ
    """
    try:
        s = serial.Serial(GPIB_DEV)
    except OSError as e:
        if e.errno == errno.ENOENT:
            raise GPIBError("serial device doesn't exist: %s" % GPIB_DEV)
        raise GPIBError('issue opening serial device: %s: %s' % (GPIB_DEV, e))

    s.bytesize = serial.EIGHTBITS
    s.parity = serial.PARITY_NONE
    s.stopbits = serial.STOPBITS_ONE
    s.timeout = 2
    s.xonxoff = False
    s.rtscts = False
    s.dsrdtr = False
    s.writeTimeout = 0

    # encode unicode strings to be written into byte strings
    def _write(string):
        s.write(string.encode())

    if not s.isOpen():
        try:
            s.open()
        except Exception as e:
            raise GPIBError(e)

    s.flushInput()
    s.flushOutput()

    # initialize GPIB adapter
    _write('++mode 1\n')
    _write('++auto 1\n')
    _write('++addr 16\n')
    _write('++ver\n')
    gpib_device = s.readline().strip()
    if not gpib_device:
        raise GPIBError('error communicating with GPIB device')

    # confirm communication with frequency counter
    _write('*CLS;*RST;*IDN?\r\n')
    instrument_id = s.readline().strip()
    if not instrument_id:
        raise GPIBError('error communicating with frequency counter')

    # request the current measured frequency
    _write('*RST;*CLS;*SRE 0;*ESE 0;\r\n')
    _write(':STAT:PRES\r\n')
    _write(':DISP:CALC:MATH:STAT OFF\r\n')
    _write(':TRAC SCALE, 1.000000\r\n')
    # we're using channel 1
    _write(":FUNC 'FREQ 1'\r\n")
    _write(':FORM:DATA ASCII\r\n')
    # send expected value and scale so returned value is properly scaled
    _write(':MEASURE:FREQ? 4e7 HZ, 1 HZ\r\n')
    freq = s.readline().strip()
    # re-enable continuous mode for the frequency counter
    _write(':INIT:CONT ON\r\n')
    s.close()
    if not freq:
        raise GPIBError('error querying counter for current frequency')

    return int(float(freq))


def get_mac_addr():
    """Get MAC address for device.

    Requires that user input the device specific portion.

    Returns: MAC address string in xx:xx:xx:xx:xx:xx format.
    """
    suffix = None
    while suffix is None:
        orig_suffix = input('Enter the MAC address suffix (e.g. 0afa34): ')
        # remove all character spacers
        strip_spacers = orig_suffix.maketrans({x: None for x in ':-.'})
        suffix = orig_suffix.translate(strip_spacers)

        # check if it's a valid hex string
        invalid_hex = False
        try:
            int(suffix, 16)
        except ValueError:
            invalid_hex = True

        if len(suffix) != 6 or invalid_hex:
            print('Invalid MAC address suffix: %s' % orig_suffix)
            suffix = None

    mac_addr = MAC_ADDR_OUI + suffix
    mac_addr = '%s%s:%s%s:%s%s:%s%s:%s%s:%s%s' % tuple(mac_addr.lower())
    return mac_addr


def uboot_expect():
    """Pexpect loop to run after the tests complete successfully."""

    if not os.path.exists(UART_DEV):
        raise UBootError('UART serial device node to picozed sdr missing')
    if not os.path.exists(GPIB_DEV):
        raise UBootError('GPIB serial device node to frequency counter missing')

    try:
        p = pexpect.spawn(
            'picocom --nolock -b 115200 %s' % (UART_DEV,),
            encoding='utf8', logfile=sys.stdout, echo=False)
    except pexpect.exceptions.ExceptionPexpect:
        raise UBootError('picocom is missing, please install it')

    timed_out = False

    # output string specifying that the u-boot command line is ready
    prompt = 'zynq-uboot> '

    def _extract_bytes(l):
        """Extract the size of the file read from u-boot output.

        Returns the file size in bytes.
        """
        # input should consist of a list of strings similar to ['123456', 'bytes', 'read']
        if len(l) != 3 or l[1] != 'bytes' or l[2] != 'read':
            raise UBootError('received unexpected reply when reading file')

        try:
            return int(l[0])
        except ValueError:
            raise UBootError('received unexpected bytes value when reading file')

    def _flash_file(filepath, offset, size, timeout=30, mem_location=0x1000000):
        """Erase and write a file to a QSPI flash partition.

        Parameters:
            filepath: path to file to write to partition
            offset: partition offset
            size: partition size
            timeout: time to wait while erasing partition (to avoid pexpect timeouts)
            mem_location: external memory location to load file to and from
        """
        # erase memory
        p.sendline('mw 0x%x 0x0 0x%x' % (mem_location, size))
        p.expect(prompt)
        # load file into memory
        p.sendline('fatload mmc 0 0x%x %s' % (mem_location, filepath))
        p.expect('.* bytes read')
        filesize = _extract_bytes(p.after.strip().split()[-3:])
        p.expect(prompt)
        # erase flash partition and write file into it
        p.sendline('sf update 0x%x 0x%x 0x%x' % (mem_location, offset, size))
        p.expect('.* bytes written, .* bytes skipped', timeout=timeout)
        p.expect(prompt)

    while 1:
        try:
            i = p.expect(['ALL TESTS PASSED', 'TESTS FAILED'])
            if i == 1:
                # tests failed, restarting loop
                continue
            p.expect(prompt)

            # drive gpio 61 high to enable ad9361 clock out on pin 3 of the P3 fanout
            p.sendline('gpio set 61 1')
            p.expect(prompt)

            # run GPIB query to determine actual ad9361 reference clock
            # frequency and save it to the u-boot environment
            try:
                freq = gpib_get_freq()
            except GPIBError:
                print('\nError querying frequency counter, restarting loop...')
                continue
            p.sendline('setenv ad9361_ext_refclk 0x%.8s' % (freq,))
            p.expect(prompt)

            p.sendline('sf probe')
            p.expect('SF: Detected N25Q256A')
            p.expect(prompt)

            # write files to flash
            _flash_file('flash/BOOT.BIN', 0x0, 0xE0000, 180)
            _flash_file('uImage', 0x100000, 0x500000, 300)
            _flash_file('devicetree.dtb', 0x600000, 0x20000)
            _flash_file('Card-Filesystem-Repair/uramdisk.image.gz', 0x620000, 0xCE0000, 600)
            _flash_file('flash/system.bit', 0x1300000, 0xD00000, 600)

            # set MAC address
            print()
            mac_addr = get_mac_addr()
            p.sendline('setenv ethaddr %s' % mac_addr)
            p.expect(prompt)
            p.sendline('saveenv')
            p.expect(prompt)
            print('\n\n############################################')
            print('Board ready for shipping')
            print('Power off and insert next module for testing')
            print('############################################')
            timed_out = False
        except pexpect.TIMEOUT:
            if not timed_out:
                print('\nTimed out waiting for u-boot output, restarting loop...')
            timed_out = True
            continue
        except KeyboardInterrupt:
            # restart the expect loop if the user hits Ctrl-C
            print('Got keyboard interrupt, restarting loop...')
            timed_out = True
            continue
        except UBootError as e:
            print('\nError running U-Boot command: %s, restarting loop...' % str(e))
            continue
    p.close()

if __name__ == '__main__':
    while 1:
        try:
            uboot_expect()
        except UBootError as e:
            enter = input('Error: %s\nHit enter to restart after fixing the issue...')
